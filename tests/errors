[----] Criterion v2.4.0
[====] Running 2 tests from tuples:
[RUN ] tuples::tuple_is_a_valid_point
[----]   [36mshows that a tuple is a point when w is 1, and its xyz are correct[0m
[PASS] tuples::tuple_is_a_valid_point: (0.00s)
[RUN ] tuples::tuple_is_a_valid_vector
[----]   [36mshows that a tuple is a vector when w is 0, and its xyz are correct[0m
[PASS] tuples::tuple_is_a_valid_vector: (0.00s)
[====] Synthesis: Tested: 2 | Passing: 2 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 5 tests from float_tests:
[RUN ] float_tests::comparing_equal_floats
[PASS] float_tests::comparing_equal_floats: (0.00s)
[RUN ] float_tests::comparing_unequal_floats
[RUN ] float_tests::comparing_unequal_floats_below_one_above_zero
[PASS] float_tests::comparing_unequal_floats: (0.00s)
[PASS] float_tests::comparing_unequal_floats_below_one_above_zero: (0.00s)
[RUN ] float_tests::comparing_unequal_floats_five_decimals
[----]   [36m
This one should give a false positive, float_a(1.00001) == float_b(1.00000)
[PASS] float_tests::comparing_unequal_floats_five_decimals: (0.00s)
[RUN ] float_tests::comparing_unequal_floats_pretty_close
[PASS] float_tests::comparing_unequal_floats_pretty_close: (0.00s)
[====] Synthesis: Tested: 5 | Passing: 5 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 6 tests from basic_tuple_operations:
[RUN ] basic_tuple_operations::adding_two_tuples
[PASS] basic_tuple_operations::adding_two_tuples: (0.00s)
[RUN ] basic_tuple_operations::multiplying_a_tuple_by_a_scalar
[RUN ] basic_tuple_operations::subtracting_two_points
[PASS] basic_tuple_operations::multiplying_a_tuple_by_a_scalar: (0.01s)
[RUN ] basic_tuple_operations::negating_a_tuple
[PASS] basic_tuple_operations::subtracting_two_points: (0.01s)
[PASS] basic_tuple_operations::negating_a_tuple: (0.01s)
[RUN ] basic_tuple_operations::subtracting_two_vectors
[PASS] basic_tuple_operations::subtracting_two_vectors: (0.00s)
[RUN ] basic_tuple_operations::subtracting_vector_from_point
[PASS] basic_tuple_operations::subtracting_vector_from_point: (0.00s)
[====] Synthesis: Tested: 6 | Passing: 6 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 6 tests from magnitude:
[RUN ] magnitude::magnitude_of_a_point_should_be_always_negative_one
[RUN ] magnitude::magnitude_of_negative_vector
[PASS] magnitude::magnitude_of_a_point_should_be_always_negative_one: (0.00s)
[PASS] magnitude::magnitude_of_negative_vector: (0.00s)
[RUN ] magnitude::magnitude_of_positive_vector
[RUN ] magnitude::magnitude_of_unit_vector1
[PASS] magnitude::magnitude_of_positive_vector: (0.00s)
[PASS] magnitude::magnitude_of_unit_vector1: (0.00s)
[RUN ] magnitude::magnitude_of_unit_vector2
[PASS] magnitude::magnitude_of_unit_vector2: (0.00s)
[RUN ] magnitude::magnitude_of_unit_vector3
[PASS] magnitude::magnitude_of_unit_vector3: (0.00s)
[====] Synthesis: Tested: 6 | Passing: 6 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 5 tests from normalization:
[RUN ] normalization::magnitude_of_normalized_vector_1_2_3
[RUN ] normalization::normalization_of_point_should_fail
[PASS] normalization::magnitude_of_normalized_vector_1_2_3: (0.00s)
[PASS] normalization::normalization_of_point_should_fail: (0.00s)
[RUN ] normalization::normalization_of_zero_magnitude_vector_should_fail
[PASS] normalization::normalization_of_zero_magnitude_vector_should_fail: (0.00s)
[RUN ] normalization::normalizing_vector_1_2_3
[PASS] normalization::normalizing_vector_1_2_3: (0.00s)
[RUN ] normalization::normalizing_vector_4_0_0
[PASS] normalization::normalizing_vector_4_0_0: (0.00s)
[====] Synthesis: Tested: 5 | Passing: 5 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 3 tests from dot_product:
[RUN ] dot_product::dot_product_of_identical_unit_vectors
[----]   [36m
Given a <-vector(1, 0, 0)
And b <- vector(1, 0, 0)
And dot(a, b, ) = 1
Then  == 1[0m
[PASS] dot_product::dot_product_of_identical_unit_vectors: (0.00s)
[RUN ] dot_product::dot_product_of_opposite_unit_vectors
[----]   [36m
Given a <-vector(-1, 0, 0)
And b <- vector(1, 0, 0)
And dot(a, b, ) = -1
Then  == -1[0m
[PASS] dot_product::dot_product_of_opposite_unit_vectors: (0.00s)
[RUN ] dot_product::dot_product_of_two_tuples
[----]   [36m
Given a ← vector(1, 2, 3)
And b ← vector(2, 3, 4)
And dot(a, b, )
Then  == 20[0m
[PASS] dot_product::dot_product_of_two_tuples: (0.00s)
[====] Synthesis: Tested: 3 | Passing: 3 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 3 tests from cross_product:
[RUN ] cross_product::cross_product_of_a_b
[----]   [36m
Given a ← vector(1, 2, 3)
And b ← vector(2, 3, 4)
And cross(a, b, result)
Then result == vector(-1, 2, -1)[0m
[PASS] cross_product::cross_product_of_a_b: (0.00s)
[RUN ] cross_product::cross_product_of_b_a
[----]   [36m
Given a ← vector(1, 2, 3)
And b ← vector(2, 3, 4)
And cross(b, a, result)
Then result == vector(1, -2, 1)[0m
[PASS] cross_product::cross_product_of_b_a: (0.00s)
[RUN ] cross_product::cross_product_of_points_should_fail
[----]   [36m
Given a ← point(1, 2, 3)
And b ← point(2, 3, 4)
Then cross(b, a) == -1
[0m
[PASS] cross_product::cross_product_of_points_should_fail: (0.00s)
[====] Synthesis: Tested: 3 | Passing: 3 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from putting_it_together:
[RUN ] putting_it_together::projectile_goes_up_and_down
[PASS] putting_it_together::projectile_goes_up_and_down: (0.51s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 5 tests from canvas:
[RUN ] canvas::constructing_the_ppm_header
[----]   [36m
Given c ← canvas(3, 5)
When ppm ← canvas_to_ppm(c)
Then lines 1-3 of ppm are:
P3
5 3
255[0m
[RUN ] canvas::creating_a_canvas
[----]   [36m
Given c ← canvas(550, 900)
Then c.width = 900 And c.height = 550
And every pixel of c is color(0, 0, 0)[0m
[PASS] canvas::constructing_the_ppm_header: (0.00s)
[RUN ] canvas::lines_longer_than_70_must_break
[----]   [36m
Scenario: Splitting long lines in PPM files
Given c ← canvas(2, 10)
When every pixel of c is set to color(1, 0.8, 0.6)
And ppm ← canvas_to_ppm(c)
Then lines 4-7 of ppm are
255 204 153 255 204 153 255 204 153 255 204 153 255 204 153 255 204
153 255 204 153 255 204 153 255 204 153 255 204 153
255 204 153 255 204 153 255 204 153 255 204 153 255 204 153 255 204
153 255 204 153 255 204 153 255 204 153 255 204 153[0m
[PASS] canvas::lines_longer_than_70_must_break: (0.00s)
[RUN ] canvas::writing_a_pixel_in_a_canvas
[----]   [36m
Given c ← canvas(20, 10)
When write_pixel(c, 2, 3, red)
Then pixel_at(c, 2, 3) = red[0m
[PASS] canvas::writing_a_pixel_in_a_canvas: (0.00s)
[RUN ] canvas::writing_the_whole_canvas_on_the_ppm_string
[----]   [36m
Given c ← canvas(3, 5)
And c1 ← color(1.0, 0, 0)
And c2 ← color(0, 0.5, 0)
And c3 ← color(-0.5, 0, 1)
When write_pixel(c, 0, 0, c1)
And write_pixel(c, 2, 1, c2)
And write_pixel(c, 4, 2, c3)
And ppm ← canvas_to_ppm(c)
Then lines 4-6 of ppm are
255 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 128 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 255[0m
[PASS] canvas::writing_the_whole_canvas_on_the_ppm_string: (0.00s)
[PASS] canvas::creating_a_canvas: (0.07s)
[====] Synthesis: Tested: 5 | Passing: 5 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 4 tests from color_operations:
[RUN ] color_operations::adding_colors
[----]   [36m
Given c1 ← color(0.9, 0.6, 0.75)
 And  c2 ← color(0.7, 0.1, 0.25)
 Then c1 + c2 = color(1.6, 0.7, 1.0)[0m
[PASS] color_operations::adding_colors: (0.00s)
[RUN ] color_operations::multipying_color_by_color
[----]   [36m
Given c1 ← color(1, 0.2, 0.4)
 And  c2 ← color(0.9, 1, 0.1)
 Then c1 * c2 = color(0.9, 0.2, 0.04)[0m
[PASS] color_operations::multipying_color_by_color: (0.00s)
[RUN ] color_operations::multipying_color_by_scalar
[----]   [36m
Given c ← color(0.2, 0.3, 0.4)
Then c * 2 = color(0.4, 0.6, 0.8)[0m
[PASS] color_operations::multipying_color_by_scalar: (0.00s)
[RUN ] color_operations::subtracting_colors
[----]   [36m
Given c1 ← color(0.9, 0.6, 0.75)
 And  c2 ← color(0.7, 0.1, 0.25)
 Then c1 - c2 = color(0.2, 0.5, 0.5)[0m
[PASS] color_operations::subtracting_colors: (0.00s)
[====] Synthesis: Tested: 4 | Passing: 4 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from representing_colors:
[RUN ] representing_colors::colors_are_rgb_tuples
[----]   [36m
Given c ← color(-0.5, 0.4, 1.7)
Then color[R] = -0.5
 And color[G] = 0.4
 And color[B] = 1.7[0m
[PASS] representing_colors::colors_are_rgb_tuples: (0.00s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from putting_it_together:
[RUN ] putting_it_together::projectile_goes_up_and_down
[PASS] putting_it_together::projectile_goes_up_and_down: (0.44s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 3 tests from creating_a_matrix:
[====] Running 2 tests from matrix_equality:
[RUN ] creating_a_matrix::4x4matrix
[----]   [36m
Given the following 4x4 matrix M:
| 1 | 2 | 3 | 4 |
| 5.5 | 6.5 | 7.5 | 8.5 |
| 9 | 10 | 11 | 12 |
| 13.5 | 14.5 | 15.5 | 16.5 |
Then M[0,0] = 1
And M[0,3] = 4
And M[1,0] = 5.5
And M[1,2] = 7.5
And M[2,2] = 11
And M[3,0] = 13.5
And M[3,2] = 15.5[0m
[PASS] creating_a_matrix::4x4matrix: (0.00s)
[RUN ] creating_a_matrix::_2x2matrix
[----]   [36mGiven the following 2x2 matrix M:
| -3 | 5 |
| 1 | -2 |
Then M[0,0] = -3
And M[0,1] = 5
And M[1,0] = 1
And M[1,1] = -2[0m
[RUN ] creating_a_matrix::_3x3matrix
[----]   [36mGiven the following 2x2 matrix M:
| -3 | 5 | 0 | 
| 1 | -2 | 7 | 
| 0 | 1 | 1 | 
Then M[0,0] = -3
And M[0,1] = 5
And M[1,0] = 1
And M[1,1] = -2
And M[2,2] = 1[0m
[PASS] creating_a_matrix::_2x2matrix: (0.00s)
[PASS] creating_a_matrix::_3x3matrix: (0.00s)
[RUN ] matrix_equality::_4x4different_matrices
[----]   [36mGiven the following matrix A:
| 1 | 2 | 3 | 4 |
| 5 | 6 | 7 | 8 |
| 9 | 8 | 7 | 6 |
| 5 | 4 | 3 | 2 |
And the following matrix B:
| 2 | 3 | 4 | 5 |
| 6 | 7 | 8 | 9 |
| 8 | 7 | 6 | 5 |
| 4 | 3 | 2 | 1 |
Then A != B[0m
[PASS] matrix_equality::_4x4different_matrices: (0.00s)
[RUN ] matrix_equality::_4x4identical_matrices
[----]   [36mGiven the following matrix A:
| 1 | 2 | 3 | 4 |
| 5 | 6 | 7 | 8 |
| 9 | 8 | 7 | 6 |
| 5 | 4 | 3 | 2 |
And the following matrix B:
| 1 | 2 | 3 | 4 |
| 5 | 6 | 7 | 8 |
| 9 | 8 | 7 | 6 |
| 5 | 4 | 3 | 2 |
Then A = B
[0m
[PASS] matrix_equality::_4x4identical_matrices: (0.00s)
[====] Synthesis: Tested: 5 | Passing: 5 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from multiplying_matrices:
[RUN ] multiplying_matrices::multiplying_two_matrices
[----]   [36m
Given the following matrix A:
| 1 | 2 | 3 | 4 |
| 5 | 6 | 7 | 8 |
| 9 | 8 | 7 | 6 |
| 5 | 4 | 3 | 2 |
And the following matrix B:
| -2 | 1 | 2 | 3 |
| 3 | 2 | 1 | -1 |
| 4 | 3 | 6 | 5 |
| 1 | 2 | 7 | 8 |
Then A * B is the following 4x4 matrix:
| 20| 22 | 50 | 48 |
| 44| 54 | 114 | 108 |
| 40| 58 | 110 | 102 |
| 16| 26 | 46 | 42 |
[PASS] multiplying_matrices::multiplying_two_matrices: (0.00s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from the_identity_matrix:
[RUN ] the_identity_matrix::Multiplying_by_identity
[----]   [36m
Given the following matrix A:
| 0 | 1 | 2 | 4 |
| 1 | 2 | 4 | 8 |
| 2 | 4 | 8 | 16 |
| 4 | 8 | 16 | 32 |
Then A * identity_matrix = A
Scenario : Multiplying the identity matrix by a tuple
Given a ← tuple(1, 2, 3, 4)
Then identity_matrix * a = a[0m
[PASS] the_identity_matrix::Multiplying_by_identity: (0.00s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 2 tests from transposing_matrices:
[RUN ] transposing_matrices::transposing_a_matrix
[----]   [36m
Given the following matrix A:
| 0 | 9 | 3 | 0 |
| 9 | 8 | 0 | 8 |
| 1 | 8 | 5 | 3 |
| 0 | 0 | 5 | 8 |
Then transpose(A) is the following matrix:
| 0 | 9 | 1 | 0 |
| 9 | 8 | 8 | 0 |
| 3 | 0 | 5 | 5 |
| 0 | 8 | 3 | 8 |[0m
[PASS] transposing_matrices::transposing_a_matrix: (0.00s)
[RUN ] transposing_matrices::transposing_identity_matrix
[----]   [36m
Given the following identity matrix A:
| 1 | 0 | 0 | 0 |
| 0 | 1 | 0 | 0 |
| 0 | 0 | 1 | 0 |
| 0 | 0 | 0 | 1 |
Then transpose(A) is the following matrix:
| 1 | 0 | 0 | 0 |
| 0 | 1 | 0 | 0 |
| 0 | 0 | 1 | 0 |
| 0 | 0 | 0 | 1 |[0m
[PASS] transposing_matrices::transposing_identity_matrix: (0.00s)
[====] Synthesis: Tested: 2 | Passing: 2 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from inverting_matrices:
[RUN ] inverting_matrices::determinant_of_2x2_matrix
[----]   [36m
Given the following 2x2 matrix A:
| 1 | 5 |
| -3 | 2 |
Then determinant(A) = 17[0m
[PASS] inverting_matrices::determinant_of_2x2_matrix: (0.00s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 2 tests from spotting_submatrices:
[RUN ] spotting_submatrices::_3x3_submatrix
[----]   [36m
Given the following 3x3 matrix A:
 | 1 | 5 | 0 |
 | -3 | 2 | 7 |
 | 0 | 6 | -3 |
 Then submatrix(A, 0, 2) is the following 2x2 matrix:
 | -3 | 2 |
 | 0 | 6 |[0m
[PASS] spotting_submatrices::_3x3_submatrix: (0.00s)
[RUN ] spotting_submatrices::submatrix_of_4x4_matrix
[----]   [36m
Given the following 4x4 matrix A:
 | -6 | 1 | 1 | 6 |
 | -8 | 5 | 8 | 6 |
 | -1 | 0 | 8 | 2 |
 | -7 | 1 | -1 | 1 |
 Then submatrix(A, 2, 1) is the following 3x3 matrix:
 | -6 | 1 | 6 |
 | -8 | 8 | 6 |
 | -7 | -1 | 1 |[0m
[PASS] spotting_submatrices::submatrix_of_4x4_matrix: (0.00s)
[====] Synthesis: Tested: 2 | Passing: 2 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from manipulating_minors:
[RUN ] manipulating_minors::calculating_a_minor_of_a_3x3_matrix
[----]   [36m
Given the following 3x3 matrix A:
 | 3 | 5 | 0 |
 | 2 | -1 | -7 |
 | 6 | -1 | 5 |
 And B ← submatrix(A, 1, 0)
 Then determinant(B) = 25
 And minor(A, 1, 0) = 25

[PASS] manipulating_minors::calculating_a_minor_of_a_3x3_matrix: (0.00s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from computing_cofactor:
[RUN ] computing_cofactor::calculating_a_cofactor_of_a_3x3_matrix
[----]   [36mGiven the following 3x3 matrix A:
 | 3 | 5 | 0 |
 | 2 | -1 | -7 |
 | 6 | -1 | 5 |
 Then minor(A, 0, 0) = -12
 And cofactor(A, 0, 0) = -12
 And minor(A, 1, 0) = 25
 And cofactor(A, 1, 0) = -25

[PASS] computing_cofactor::calculating_a_cofactor_of_a_3x3_matrix: (0.00s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from cofactor:
[====] Running 2 tests from determinant_large_matrices:
[RUN ] cofactor::a_1_1
[PASS] cofactor::a_1_1: (0.00s)
[RUN ] determinant_large_matrices::calculating_the_determinant_of_a_3x3_matrix
[----]   [36m
Given the following 3x3 matrix A:
| 1 | 2 | 6 |
| -5 | 8 | -4 |
| 2 | 6 | 4 |
Then cofactor(A, 0, 0) = 56
And cofactor(A, 0, 1) = 12
And cofactor(A, 0, 2) = -46
And determinant(A) = -196
[PASS] determinant_large_matrices::calculating_the_determinant_of_a_3x3_matrix: (0.00s)
[RUN ] determinant_large_matrices::calculating_the_determinant_of_a_4x4_matrix
[----]   [36m
Given the following 4x4 matrix A:
| -2 | -8 | 3 | 5 |
| -3 | 1 | 7 | 3 |
| 1 | 2 | -9 | 6 |
| -6 | 7 | 7 | -9 |
Then cofactor(A, 0, 0) = 690
And cofactor(A, 0, 1) = 447
And cofactor(A, 0, 2) = 210
And cofactor(A, 0, 3) = 51
And determinant(A) = -4071
[PASS] determinant_large_matrices::calculating_the_determinant_of_a_4x4_matrix: (0.00s)
[====] Synthesis: Tested: 3 | Passing: 3 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 7 tests from inversion:
[RUN ] inversion::calculating_the_inverse_of_a_matrix
[----]   [36m
Given the following 4x4 matrix A:
 | -5 | 2 | 6 | -8 |
 | 1 | -5 | 1 | 8 |
 | 7 | 7 | -6 | -7 |
 | 1 | -3 | 7 | 4 |
 And B ← invert_matrix(A)
 Then _4x4determinant(A) = 532
 And cofactor(A, 2, 3) = -160
 And B[3,2] = -160/532
 And cofactor(A, 3, 2) = 105
 And B[2,3] = 105/532
 And B is the following 4x4 matrix:
 | 0.21805 | 0.45113 | 0.24060 | -0.04511 |
 | -0.80827 | -1.45677 | -0.44361 | 0.52068 |
 | -0.07895 | -0.22368 | -0.05263 | 0.19737 |
 | -0.52256 | -0.81391 | -0.30075 | 0.30639 |
[PASS] inversion::calculating_the_inverse_of_a_matrix: (0.00s)
[RUN ] inversion::calculating_the_inverse_of_a_third_matrix
[----]   [36m
Given the following 4x4 matrix A:
| 9 | 3 | 0 | 9 |
| -5 | -2 | -6 | -3 |
| -4 | 9 | 6 | 4 |
| -7 | 6 | 6 | 2 |
Then invert_matrix(A) is the following 4x4 matrix:
| -0.04074 | -0.07778 | 0.14444 | -0.22222 |
| -0.07778 | 0.03333 | 0.36667 | -0.33333 |
| -0.02901 | -0.14630 | -0.10926 | 0.12963 |
| 0.17778 | 0.06667 | -0.26667 | 0.33333 |
[PASS] inversion::calculating_the_inverse_of_a_third_matrix: (0.00s)
[RUN ] inversion::calculating_the_inverse_of_another_matrix
[----]   [36m
Given the following 4x4 matrix A:
| 8 | -5 | 9 | 2 |
| 7 | 5 | 6 | 1 |
| -6 | 0 | 9 | 6 |
| -3 | 0 | -9 | -4 |
Then invert_matrix(A) is the following 4x4 matrix:
| -0.15385 | -0.15385 | -0.28205 | -0.53846 |
| -0.07692 | 0.12308 | 0.02564 | 0.03077 |
| 0.35897 | 0.35897 | 0.43590 | 0.92308 |
| -0.69231 | -0.69231 | -0.76923 | -1.92308 |
[PASS] inversion::calculating_the_inverse_of_another_matrix: (0.00s)
[RUN ] inversion::identity_matrix_inversion
[----]   [36m
Given the following identity matrix A:
| 1 | 0 | 0 | 0 |
| 0 | 1 | 0 | 0 |
| 0 | 0 | 1 | 0 |
| 0 | 0 | 0 | 1 |
Then inverted(A) is the following matrix:
| 1 | 0 | 0 | 0 |
| 0 | 1 | 0 | 0 |
| 0 | 0 | 1 | 0 |
| 0 | 0 | 0 | 1 |[0m
[PASS] inversion::identity_matrix_inversion: (0.00s)
[RUN ] inversion::multiplying_a_product_by_its_inverse
[----]   [36m
Given the following 4x4 matrix A:
| 3 | -9 | 7 | 3 |
| 3 | -8 | 2 | -9 |
| -4 | 4 | 4 | 1 |
| -6 | 5 | -1 | 1 |
And the following 4x4 matrix B:
| 8 | 2 | 2 | 2 |
| 3 | -1 | 7 | 0 |
| 7 | 0 | 5 | 4 |
| 6 | -2 | 0 | 5 |
And C ← A * B
Then C * invert_matrix(B) = A
[PASS] inversion::multiplying_a_product_by_its_inverse: (0.00s)
[RUN ] inversion::testing_a_noninvertible_matrix_for_invertibility
[----]   [36m
Given the following 4x4 matrix A:
 | -4 | 2 | -2 | -3 |
 | 9 | 6 | 2 | 6 |
 | 0 | -5 | 1 | -5 |
 | 0 | 0 | 0 | 0 |
 Then _4x4determinant(A) = 0
 And A is not invertible

[PASS] inversion::testing_a_noninvertible_matrix_for_invertibility: (0.00s)
[RUN ] inversion::testing_an_invertible_matrix_for_invertibility
[----]   [36m
Given the following 4x4 matrix A:
 | 6 | 4 | 4 | 4 |
 | 5 | 5 | 7 | 6 |
 | 4 | -9 | 3 | -7 |
 | 9 | 1 | 7 | -6 |
 Then _4x4determinant(A) = -2120
 And A is invertible
[PASS] inversion::testing_an_invertible_matrix_for_invertibility: (0.00s)
[====] Synthesis: Tested: 7 | Passing: 7 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 3 tests from translation:
[RUN ] translation::multiplying_by_inverse_of_translation
[----]   [36m
Given translation_matrix ← translation(5, -3, 2)
And inv ← inverse(translation_matrix)
And p ← point(-3, 4, 5)
Then inv * p = point(-8, 7, 3)[0m
[PASS] translation::multiplying_by_inverse_of_translation: (0.00s)
[RUN ] translation::multiplying_by_translation_matrix
[----]   [36m
Given translation_matrix ← translation(5, -3, 2)
And p ← point(-3, 4, 5)
Then translation_matrix * p = point(2, 1, 7)[0m
[PASS] translation::multiplying_by_translation_matrix: (0.00s)
[RUN ] translation::translation_shouldnt_affect_vectors
[----]   [36m
Given translation_matrix ← translation(5, -3, 2)And v ← vector(-3, 4, 5)
Then translation_matrix * v = v[0m
[PASS] translation::translation_shouldnt_affect_vectors: (0.00s)
[====] Synthesis: Tested: 3 | Passing: 3 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 4 tests from scaling:
[RUN ] scaling::apply_scaling_matrix_to_a_point
[----]   [36m
Given transform ← scaling(2, 3, 4)
And p ← point(-4, 6, 8)
Then transform * p = point(-8, 18, 32)

[RUN ] scaling::apply_scaling_matrix_to_a_vector
[----]   [36m
Given transform ← scaling(2, 3, 4)
And v ← vector(-4, 6, 8)
Then transform * v = vector(-8, 18, 32)
 
[PASS] scaling::apply_scaling_matrix_to_a_point: (0.00s)
[PASS] scaling::apply_scaling_matrix_to_a_vector: (0.00s)
[RUN ] scaling::multiply_by_inverse_scaling_matrix
[----]   [36m
Given transform ← scaling(2, 3, 4)
And inv ← inverse(transform)
And v ← vector(-4, 6, 8)
Then inv * v = vector(-2, 2, 2)

[PASS] scaling::multiply_by_inverse_scaling_matrix: (0.00s)
[RUN ] scaling::scaling_by_negative_value
[----]   [36mGiven transform ← scaling(-1, 1, 1)
And p ← point(2, 3, 4)
Then transform * p = point(-2, 3, 4)

[PASS] scaling::scaling_by_negative_value: (0.00s)
[====] Synthesis: Tested: 4 | Passing: 4 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 4 tests from rotation:
[RUN ] rotation::rotating_around_x_axis
[----]   [36m
Given p ← point(0, 1, 0)
And half_quarter ← create_x_rotation_matrix(π / 4)
And full_quarter ← create_x_rotation_matrix(π / 2)
Then half_quarter * p = point(0, 0.707107, 0.707107)
And full_quarter * p = point(0, 0, 1)[0m
[PASS] rotation::rotating_around_x_axis: (0.00s)
[RUN ] rotation::rotating_around_y_axis
[----]   CYAN
Given p ← point(0, 0, 1)
And half_quarter ← rotation_y(π / 4)
And full_quarter ← rotation_y(π / 2)
Then half_quarter * p = point(0.707107, 0, 0.707107)
And full_quarter * p = point(1, 0, 0)[0m
[PASS] rotation::rotating_around_y_axis: (0.00s)
[RUN ] rotation::rotating_around_z_axis
[----]   CYAN
Given p ← point(0, 1, 0)And half_quarter ← rotation_z(π / 4)
And full_quarter ← rotation_z(π / 2)
Then half_quarter * p = point(-0.707107, 0.707107, 0)
And full_quarter * p = point(-1, 0, 0)[0m
[PASS] rotation::rotating_around_z_axis: (0.00s)
[RUN ] rotation::the_inverse_of_the_rotation_matrix_rotates_in_the_opposite_direction
[----]   CYAN
Given p ← point(0, 1, 0)
And half_quarter ← rotation_x(π / 4)
And inv ← inverse(half_quarter)
Then inv * p = point(0, 0.707107, -0.707107)[0m
[PASS] rotation::the_inverse_of_the_rotation_matrix_rotates_in_the_opposite_direction: (0.00s)
[====] Synthesis: Tested: 4 | Passing: 4 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 7 tests from shearing:
[RUN ] shearing::shear_x_in_proportion_to_y
[----]   [36m
Given transform ← create_shearing_matrix(1, 0, 0, 0, 0, 0)
And p ← point(2, 3, 4)
Then transform * p = point(5, 3, 4)[0m
[RUN ] shearing::shear_x_in_proportion_to_z
[----]   [36mGiven transform ← create_shearing_matrix(0, 1, 0, 0, 0, 0)
And p ← point(2, 3, 4)
Then transform * p = point(6, 3, 4)[0m
[PASS] shearing::shear_x_in_proportion_to_y: (0.00s)
[PASS] shearing::shear_x_in_proportion_to_z: (0.00s)
[RUN ] shearing::shear_y_in_proportion_to_x
[----]   [36mGiven transform ← create_shearing_matrix(0, 0, 1, 0, 0, 0)
And p ← point(2, 3, 4)
Then transform * p = point(2, 5, 4)[0m
[RUN ] shearing::shear_y_in_proportion_to_z
[----]   [36mGiven transform ← create_shearing_matrix(0, 0, 0, 1, 0, 0)
And p ← point(2, 3, 4)
Then transform * p = point(2, 7, 4)[0m
[PASS] shearing::shear_y_in_proportion_to_x: (0.00s)
[PASS] shearing::shear_y_in_proportion_to_z: (0.00s)
[RUN ] shearing::shear_z_in_proportion_to_x
[----]   [36mGiven transform ← create_shearing_matrix(0, 0, 0, 0, 1, 0)
And p ← point(2, 3, 4)
Then transform * p = point(2, 3, 6)[0m
[PASS] shearing::shear_z_in_proportion_to_x: (0.00s)
[RUN ] shearing::shear_z_in_proportion_to_y
[----]   [36mGiven transform ← create_shearing_matrix(0, 0, 0, 0, 0, 1)
And p ← point(2, 3, 4)
Then transform * p = point(2, 3, 7)[0m
[PASS] shearing::shear_z_in_proportion_to_y: (0.00s)
[RUN ] shearing::t_shearing_exists
[----]   [36m
Given t_shearer shearer = {1, 0, 4, 0, 0, 0}
Then shearer.x_to_y == 1
and shearer.x_to_z == 0
and shearer.y_to_x == 4
and shearer.y_to_z == 0
and shearer.z_to_x == 0
and shearer.z_to_y == 0[0m
[PASS] shearing::t_shearing_exists: (0.00s)
[====] Synthesis: Tested: 7 | Passing: 7 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 2 tests from chaining_transformations:
[RUN ] chaining_transformations::join
[----]   [36m
Given p ← point(1, 0, 1)
And A ← rotation_x(π / 2)
And B ← scaling(5, 5, 5)
And C ← translation(10, 5, 7)
# apply rotation first
When p2 ← A * p
Then p2 = point(1, -1, 0)
# then apply scaling
When p3 ← B * p2
Then p3 = point(5, -5, 0)
# then apply translation
When p4 ← C * p3
Then p4 = point(15, 0, 7)

[PASS] chaining_transformations::join: (0.00s)
[RUN ] chaining_transformations::reverse_order
[----]   [36m
Given p ← point(1, 0, 1)
And A ← rotation_x(π / 2)
And B ← scaling(5, 5, 5)
And C ← translation(10, 5, 7)
When T ← C * B * A
Then T * p = point(15, 0, 7)

[PASS] chaining_transformations::reverse_order: (0.00s)
[====] Synthesis: Tested: 2 | Passing: 2 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from putting_it_together:
[RUN ] putting_it_together::drawing_whole_clock
[----]   [36m
 Given canvas(1080, 1920)
And twelve_o'clock(0, -450)
And R <- create_z_rotation_matrix(π/6)
Then draw_clock(twelve_o'clock, R, canvas) -> (draws a whole clock)
[0m
[PASS] putting_it_together::drawing_whole_clock: (2.78s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 2 tests from creating_rays:
[RUN ] creating_rays::create_and_query_a_ray
[----]   [36m
Given origin ← point(1, 2, 3)
And direction ← vector(4, 5, 6)
When r ← ray(origin, direction)
Then r.origin = origin
And r.direction = direction[0m
[PASS] creating_rays::create_and_query_a_ray: (0.00s)
[RUN ] creating_rays::point_from_distance
[----]   [36mGiven r ← ray(point(2, 3, 4), vector(1, 0, 0))
Then position(r, 0) = point(2, 3, 4)
And position(r, 1) = point(3, 3, 4)
And position(r, -1) = point(1, 3, 4)
And position(r, 2.5) = point(4.5, 3, 4)[0m
[PASS] creating_rays::point_from_distance: (0.00s)
[====] Synthesis: Tested: 2 | Passing: 2 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 5 tests from intersecting_rays:
[RUN ] intersecting_rays::intersects_at_two_points
[----]   [36m
Given r ← ray(point(0, 0, -5), vector(0, 0, 1))
And s ← sphere()
When inters ← intersect(s, r)
Then inters.count = 2
And inters.head->t = 4.0
And inters.head->next->t = 6.0
[0m
[RUN ] intersecting_rays::intersects_nothing
[----]   [36m
Given r ← ray(point(0, 2, -5), vector(0, 0, 1))
And s ← sphere()
When i ← intersect(s, r)
Then i.count == 0
And i.head == NULL[0m
[PASS] intersecting_rays::intersects_at_two_points: (0.00s)
[PASS] intersecting_rays::intersects_nothing: (0.00s)
[RUN ] intersecting_rays::ray_starts_inside_of_a_sphere
[----]   [36m
Given r ← ray(point(0, 0, 0), vector(0, 0, 1))
And s ← sphere()
When i ← intersect(s, r)
Then i.count = 2
And i.head->t = -1.0
And i.head->next->t = 1.0[0m
[PASS] intersecting_rays::ray_starts_inside_of_a_sphere: (0.00s)
[RUN ] intersecting_rays::sphere_is_behind_the_ray
[----]   [36m
Given r ← ray(point(0, 0, 5), vector(0, 0, 1))And s ← sphere()
When i ← intersect(s, r)
Then i.count == 2
And i.head->t == -6.0
And i.head->next->t == -4.0
[0m
[PASS] intersecting_rays::sphere_is_behind_the_ray: (0.00s)
[RUN ] intersecting_rays::tangent_intersection
[----]   [36m
Given r ← ray(point(0, 1, -5), vector(0, 0, 1))
And s ← sphere()
When inter ← intersect(s, r)
Then inter.count = 1
And inter.head->t = 5.0

[PASS] intersecting_rays::tangent_intersection: (0.00s)
[====] Synthesis: Tested: 5 | Passing: 5 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 4 tests from discriminant:
[RUN ] discriminant::inside_sphere_positive_discriminant
[----]   [36m
Given ray.origin(0, 0, 0)
And ray.direction(0, 0, 1)
And sphere <- sphere()
And point distance_sphere_to_ray <- subtract_vecs(ray.origin - sphere.origin)
When discriminant ← discriminant(ray, distance_sphere_to_ray)
Then discriminant should be a positive value[0m
[RUN ] discriminant::negative_discriminant_no_intersections
[----]   [36m
Given ray.origin(0, 2, -5)
And ray.direction(0, 0, 1)
And sphere <- sphere()
And point distance_sphere_to_ray <- subtract_vecs(ray.origin - sphere.origin)
When discriminant ← discriminant(ray, distance_sphere_to_ray)
Then discriminant should be a negative value[0m
[PASS] discriminant::inside_sphere_positive_discriminant: (0.00s)
[PASS] discriminant::negative_discriminant_no_intersections: (0.00s)
[RUN ] discriminant::positive_discriminant_two_intersections
[----]   [36m
Given ray.origin(0, 2, -5)
And ray.direction(0, 0, 1)
And sphere <- sphere()
And point distance_sphere_to_ray <- subtract_vecs(ray.origin - sphere.origin)
When discriminant ← discriminant(ray, distance_sphere_to_ray)
Then discriminant should be a negative value[0m
[PASS] discriminant::positive_discriminant_two_intersections: (0.00s)
[RUN ] discriminant::single_intersection_discriminant_is_zero
[----]   [36m
Given ray.origin(0, 1, -5)
And ray.direction(0, 0, 1)
And sphere <- sphere()
And point distance_sphere_to_ray <- subtract_vecs(ray.origin - sphere.origin)
When discriminant ← discriminant(ray, distance_sphere_to_ray)
The discriminant should be a positive value[0m
[PASS] discriminant::single_intersection_discriminant_is_zero: (0.00s)
[====] Synthesis: Tested: 4 | Passing: 4 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 3 tests from intersection:
[RUN ] intersection::aggregation_intersections
[----]   [36m
Given s ← sphere()
And i1 ← intersection(1, s)
And i2 ← intersection(2, s)
When xs ← intersections(i1, i2)
Then xs.count = 2
And xs[0].t = 1
And xs[1].t = 2
[0m
[PASS] intersection::aggregation_intersections: (0.00s)
[RUN ] intersection::encapsulates_t_and_object
[----]   [36m
Given s ← sphere() 
When i ← intersection(3.5, s)
Then i.t = 3.5
And i.object = s
[0m
[PASS] intersection::encapsulates_t_and_object: (0.00s)
[RUN ] intersection::sets_the_object
[----]   [36m
Given r ← ray(point(0, 0, -5), vector(0, 0, 1))
And s ← sphere()
When xs ← intersect(s, r)
Then xs.count = 2
And xs[0].object = s
And xs[1].object = s
[0m
[PASS] intersection::sets_the_object: (0.00s)
[====] Synthesis: Tested: 3 | Passing: 3 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 4 tests from identifying_hits:
[RUN ] identifying_hits::all_negatives
[----]   [36mGiven s ← sphere()
And i1 ← intersection(-2, s)
And i2 ← intersection(-1, s)
And xs ← intersections(i2, i1)
When hit ← get_hit(xs)
Then hit is nothing
[0m
[RUN ] identifying_hits::hit_is_alway_lowest_nonnegative_intersection
[----]   [36mGiven s ← sphere()
And i1 ← intersection(5, s)
And i2 ← intersection(7, s)
And i3 ← intersection(-3, s)
And i4 ← intersection(2, s)
And xs ← intersections(i1, i2, i3, i4)
When hit ← get_hit(xs)
Then hit = i4
[0m
[PASS] identifying_hits::all_negatives: (0.00s)
[PASS] identifying_hits::hit_is_alway_lowest_nonnegative_intersection: (0.00s)
[RUN ] identifying_hits::negative_t
[----]   [36mGiven s ← sphere()
And i1 ← intersection(-1, s)
And i2 ← intersection(1, s)
And xs ← intersections(i2, i1)
When hit ← get_hit(xs)
Then hit = i2
[0m
[PASS] identifying_hits::negative_t: (0.00s)
[RUN ] identifying_hits::positive_t
[----]   [36mGiven s ← sphere()
And i1 ← intersection(1, s)
And i2 ← intersection(2, s)
And xs ← intersections(i2, i1)
When hit ← get_hit(xs)
Then hit = i1
[0m
[PASS] identifying_hits::positive_t: (0.00s)
[====] Synthesis: Tested: 4 | Passing: 4 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 6 tests from transforming_rays_and_spheres:
[RUN ] transforming_rays_and_spheres::changing_sphere_transformation
[----]   [36m
Given s ← sphere()
And T ← translation(2, 3, 4)
When set_transform(s, T)
Then s._t == T
Then s.inverse_t == invert_matrix(T)[0m
[PASS] transforming_rays_and_spheres::changing_sphere_transformation: (0.00s)
[RUN ] transforming_rays_and_spheres::default_sphere_transformation
[----]   [36m
Given s ← sphere()

Then s.transform = identity_matrix[0m
[RUN ] transforming_rays_and_spheres::intersecting_a_translated_sphere
[----]   [36m
Given r ← ray(point(0, 0, -5), vector(0, 0, 1))
And s ← sphere()
When s.transform = translation(5, 0, 0)
And xs ← create_intersection(s, r)
Then xs.count = 0[0m
[PASS] transforming_rays_and_spheres::default_sphere_transformation: (0.00s)
[PASS] transforming_rays_and_spheres::intersecting_a_translated_sphere: (0.00s)
[RUN ] transforming_rays_and_spheres::intersecting_scaled_sphere_with_a_ray
[----]   [36m
Given r ← ray(point(0, 0, -5), vector(0, 0, 1))
And s ← sphere()
When s.transform = create_scaling_matrix(2, 2, 2)
And xs ← create_intersection(s, r)
Then xs.count = 2
And xs.head->t = 3
And xs.next->t = 7[0m
[PASS] transforming_rays_and_spheres::intersecting_scaled_sphere_with_a_ray: (0.00s)
[RUN ] transforming_rays_and_spheres::scaling_a_ray
[----]   [36m
Given r ← ray(point(1, 2, 3), vector(0, 1, 0))
And m ← scaling(2, 3, 4)
When r2 ← transform(r, m)
Then r2.origin = point(2, 6, 12)
And r2.direction = vector(0, 3, 0)[0m
[PASS] transforming_rays_and_spheres::scaling_a_ray: (0.00s)
[RUN ] transforming_rays_and_spheres::translating_a_ray
[----]   [36m
Given r ← ray(point(1, 2, 3), vector(0, 1, 0))
And T ← translation(3, 4, 5)
When r2 ←  transform_ray(r, T) 
Then r2.origin = point(4, 6, 8)
And r2.direction = vector(0, 1, 0)[0m
[PASS] transforming_rays_and_spheres::translating_a_ray: (0.00s)
[====] Synthesis: Tested: 6 | Passing: 6 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from putting_it_together:
[RUN ] putting_it_together::drawing_a_circle
[PASS] putting_it_together::drawing_a_circle: (1.94s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 7 tests from surface_normals:
[RUN ] surface_normals::normal_on_a_transformed_sphere
[----]   [36m
Given s ← sphere()
And t ← scaling(1, 0.5, 1) * rotation_z(π/5)
And set_transform(s, t)
When n ← sphere_normal_at(s, point(0, √2/2, -√2/2))
Then n = vector(0, 0.97014, -0.24254)
[0m
[RUN ] surface_normals::normal_on_a_translated_sphere
[----]   [36m
Given s ← sphere()
And set_transform(s, translation(0, 1, 0))
When n ← sphere_normal_at(s, point(0, 1.70711, -0.70711))
Then n = vector(0, 0.70711, -0.70711)[0m
[PASS] surface_normals::normal_on_a_transformed_sphere: (0.00s)
[PASS] surface_normals::normal_on_a_translated_sphere: (0.00s)
[RUN ] surface_normals::sphere_normal_at_nonaxial_point
[----]   [36m
Given s ← create_sphere()
When n ← sphere_normal_at(s, point(√3/3, √3/3, √3/3))
Then n = vector(√3/3, √3/3, √3/3)

[RUN ] surface_normals::sphere_normal_at_x_axial_point
[----]   [36m
Given s ← create_sphere()
When n ← sphere_normal_at(s, point(1, 0, 0))
Then n = vector(1, 0, 0)[0m
[PASS] surface_normals::sphere_normal_at_nonaxial_point: (0.00s)
[PASS] surface_normals::sphere_normal_at_x_axial_point: (0.00s)
[RUN ] surface_normals::sphere_normal_at_y_axial_point
[----]   [36m
Given s ← create_sphere()
When n ← sphere_normal_at(s, point(0, 1, 0))
Then n = vector(0, 1, 0)[0m
[PASS] surface_normals::sphere_normal_at_y_axial_point: (0.00s)
[RUN ] surface_normals::sphere_normal_at_z_axial_point
[----]   [36m
Given s ← create_sphere()
When n ← sphere_normal_at(s, point(0, 0, 1))
Then n = vector(0, 0, 1)[0m
[PASS] surface_normals::sphere_normal_at_z_axial_point: (0.00s)
[RUN ] surface_normals::the_normal_is_normalized
[----]   [36m
Given s ← sphere()
When n ← sphere_normal_at(s, point(√3/3, √3/3, √3/3))
Then n = normalize(n)[0m
[PASS] surface_normals::the_normal_is_normalized: (0.00s)
[====] Synthesis: Tested: 7 | Passing: 7 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 2 tests from reflecting:
[RUN ] reflecting::approaching_at_45
[----]   [36m
Given v ← vector(1, -1, 0)
And n ← vector(0, 1, 0)
When r ← reflect(v, n)
Then r = vector(1, 1, 0)

[PASS] reflecting::approaching_at_45: (0.00s)
[RUN ] reflecting::reflecting_a_vector
[----]   [36m
Given v ← vector(1, -1, 0)
And n ← vector(0, 1, 0)
When r ← reflect(v, n)
Then r = vector(1, 1, 0)

[PASS] reflecting::reflecting_a_vector: (0.00s)
[====] Synthesis: Tested: 2 | Passing: 2 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 8 tests from phong_reflection:
[RUN ] phong_reflection::a_sphere_is_created_with_a_default_material_in_it
[----]   [36m
Given s ← sphere()
When m ← s.material
Then m = material()[0m
[RUN ] phong_reflection::lighting_with_eye_between_light_and_surface
[----]   [36m
Given m ← material()
And position ← point(0, 0, 0)
Given eye_vec ← vector(0, 0, -1)
And normal_vec ← vector(0, 0, -1)
And light ← point_light(point(0, 0, -10), color(1, 1, 1))
When result ← lighting(m, light, position, eye_vec, normal_vec)
Then result = color(1.9, 1.9, 1.9)[0m
[PASS] phong_reflection::a_sphere_is_created_with_a_default_material_in_it: (0.00s)
[PASS] phong_reflection::lighting_with_eye_between_light_and_surface: (0.00s)
[RUN ] phong_reflection::lighting_with_eye_between_light_and_surface_offset_45
[----]   [36m
Given eye_vec ← vector(0, √2/2, -√2/2)
And normal_vec ← vector(0, 0, -1)
And light ← point_light(point(0, 0, -10), color(1, 1, 1))
When result ← lighting(m, light, position, eye_vec, normal_vec)
Then result = color(1.0, 1.0, 1.0)[0m
[PASS] phong_reflection::lighting_with_eye_between_light_and_surface_offset_45: (0.00s)
[RUN ] phong_reflection::lighting_with_eye_in_the_path_of_reflection_vector
[----]   [36m
Given eye_vec ← vector(0, -√2/2, -√2/2)
And normal_vec ← vector(0, 0, -1)
And light ← point_light(point(0, 10, -10), color(1, 1, 1))
When result ← lighting(m, light, position, eye_vec, normal_vec)
Then result = color(1.6364, 1.6364, 1.6364)[0m
[PASS] phong_reflection::lighting_with_eye_in_the_path_of_reflection_vector: (0.00s)
[RUN ] phong_reflection::lighting_with_eye_opposite_surface_light_offset_45
[----]   [36m
Given eye_vec ← vector(0, 0, -1)
And normal_vec ← vector(0, 0, -1)
And light ← point_light(point(0, 10, -10), color(1, 1, 1))
When result ← lighting(m, light, position, eye_vec, normal_vec)
Then result = color(0.7364, 0.7364, 0.7364)[0m
[RUN ] phong_reflection::lighting_with_light_behind_surface
[----]   [36m
Given eye_vec ← vector(0, 0, -1)
And normal_vec ← vector(0, 0, -1)
And light ← point_light(point(0, 0, 10), color(1, 1, 1))
When result ← lighting(m, light, position, eye_vec, normal_vec)
Then result = color(0.1, 0.1, 0.1)[0m
[PASS] phong_reflection::lighting_with_eye_opposite_surface_light_offset_45: (0.00s)
[PASS] phong_reflection::lighting_with_light_behind_surface: (0.00s)
[RUN ] phong_reflection::t_point_light_exists
[----]   [36m
Given intensity ← color(1, 1, 1)
And position ← point(0, 0, 0)
When light ← create_point_light(position, intensity)
Then light.position = position
And light.intensity = intensity[0m
[PASS] phong_reflection::t_point_light_exists: (0.00s)
[RUN ] phong_reflection::the_default_material
[----]   [36m
Given m ← create_material()
Then m.color = color(1, 1, 1)
And m.ambient = 0.1
And m.diffuse = 0.9
And m.specular = 0.9
And m.shininess = 200.0[0m
[PASS] phong_reflection::the_default_material: (0.00s)
[====] Synthesis: Tested: 8 | Passing: 8 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 10 tests from building_world:
[RUN ] building_world::create_world
[----]   [36m
Given w ← create_world()
Then w contains no objects
And w has no light source[0m
[PASS] building_world::create_world: (0.00s)
[RUN ] building_world::hit_when_intersection_is_inside
[----]   [36mAnd shape ← create_sphere()

Given r ← ray(point(0, 0, 0), vector(0, 0, 1))
And i ← intersection(1, shape)
When prep_comps ← prepare_computations(i, r)
Then prep_comps.point = point(0, 0, 1)
And prep_comps.eyev = vector(0, 0, -1)
And prep_comps.inside = true
// normal would have been (0, 0, 1), but is inverted!
And prep_comps.normalv = vector(0, 0, -1)[0m
[PASS] building_world::hit_when_intersection_is_inside: (0.00s)
[RUN ] building_world::hit_when_intersection_is_outside
[----]   [36m
Given r ← ray(point(0, 0, -5), vector(0, 0, 1))
And shape ← create_sphere()
And i ← intersection(4, shape)
When prep_comps ← prepare_computations(i, r)
Then prep_comps.inside = false[0m
[PASS] building_world::hit_when_intersection_is_outside: (0.00s)
[RUN ] building_world::precomputing_the_state_of_an_intersection
[----]   [36m
Given r ← ray(point(0, 0, -5), vector(0, 0, 1))
And shape ← create_sphere()
And i ← intersection(4, shape)
When prep_comps ← prepare_computations(i, r)
Then prep_comps.t = i.t
And prep_comps.object = i.object
And prep_comps.point = point(0, 0, -1)
And prep_comps.eyev = vector(0, 0, -1)
And prep_comps.normalv = vector(0, 0, -1)[0m
[RUN ] building_world::shading_intersection
[----]   [36m
Given w ← default_world()
And r ← ray(point(0, 0, -5), vector(0, 0, 1))
And shape ← the first object in w
And i ← intersection(4, shape)
When prep_comps ← prepare_computations(i, r)
And c ← shade_hit(w, prep_comps)
Then c = color(0.38066, 0.47583, 0.2855)[0m
[PASS] building_world::precomputing_the_state_of_an_intersection: (0.00s)
[PASS] building_world::shading_intersection: (0.00s)
[RUN ] building_world::shading_intersection_from_inside
[----]   [36m
Given w ← default_world()
And w.light ← point_light(point(0, 0.25, 0), color(1, 1, 1))
And r ← ray(point(0, 0, 0), vector(0, 0, 1))
And shape ← the second object in w
And i ← intersection(0.5, shape)
When prep_comps ← prepare_computations(i, r)
And c ← shade_hit(w, prep_comps)
Then c = color(0.90498, 0.90498, 0.90498)[0m
[RUN ] building_world::the_color_when_a_ray_hits
[----]   [36m
Given w ← default_world()
And r ← ray(point(0, 0, -5), vector(0, 0, 1))
When c ← color_at(w, r)
Then c = color(0.38066, 0.47583, 0.2855[0m
[PASS] building_world::the_color_when_a_ray_hits: (0.00s)
[PASS] building_world::shading_intersection_from_inside: (0.00s)
[RUN ] building_world::the_color_when_a_ray_misses
[----]   [36m
Given w ← default_world()
And r ← ray(point(0, 0, -5), vector(0, 1, 0))
When c ← color_at(w, r)
Then c = color(0, 0, 0)[0m
[PASS] building_world::the_color_when_a_ray_misses: (0.00s)
[RUN ] building_world::the_color_with_intersection_behind_ray
[----]   [36m
Given w ← default_world()
And outer ← the first object in w
And outer.material.ambient ← 1
And inner ← the second object in w
And inner.material.ambient ← 1
And r ← ray(point(0, 0, 0.75), vector(0, 0, -1))
When c ← color_at(w, r)
Then c = inner.material.color[0m
[PASS] building_world::the_color_with_intersection_behind_ray: (0.00s)
[RUN ] building_world::the_default_world
[----]   [36m
Given light ← point_light(point(-10, 10, -10), color(1, 1, 1))
And s1 ← create_sphere() with:
material.color == (0.8, 1.0, 0.6)
material.diffuse == 0.7
material.specular == 0.2
And s2 ← sphere() with:
set_transform(s, scaling(0.5, 0.5, 0.5)) 
When w ← default_world()
Then w.light = light
And w contains s1
And w contains s2[0m
[PASS] building_world::the_default_world: (0.00s)
[====] Synthesis: Tested: 10 | Passing: 10 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 3 tests from building_world:
[RUN ] building_world::the_color_when_a_ray_hits
[----]   [36m
Given w ← default_world()
And r ← ray(point(0, 0, -5), vector(0, 0, 1))
When c ← color_at(w, r)
Then c = color(0.38066, 0.47583, 0.2855[0m
[PASS] building_world::the_color_when_a_ray_hits: (0.00s)
[RUN ] building_world::the_color_when_a_ray_misses
[----]   [36m
Given w ← default_world()
And r ← ray(point(0, 0, -5), vector(0, 1, 0))
When c ← color_at(w, r)
Then c = color(0, 0, 0)[0m
[PASS] building_world::the_color_when_a_ray_misses: (0.00s)
[RUN ] building_world::the_color_with_intersection_behind_ray
[----]   [36m
Given w ← default_world()
And outer ← the first object in w
And outer.material.ambient ← 1
And inner ← the second object in w
And inner.material.ambient ← 1
And r ← ray(point(0, 0, 0.75), vector(0, 0, -1))
When c ← color_at(w, r)
Then c = inner.material.color[0m
[PASS] building_world::the_color_with_intersection_behind_ray: (0.00s)
[====] Synthesis: Tested: 3 | Passing: 3 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 4 tests from view_transformation:
[RUN ] view_transformation::arbitrary_transformation
[----]   [36mGiven from ← point(1, 3, 2)
And to ← point(4, -2, 8)
And up ← vector(1, 1, 0)
When t ← view_transform(from, forward, up)
Then t is the following 4x4 matrix:
| -0.50709 | 0.50709 | 0.67612  | -2.36643 |
| 0.76772  | 0.60609 | 0.12122  | -2.82843 |
| -0.35857 | 0.59761 | -0.71714 | 0.00000  |
| 0.00000  | 0.00000 | 0.00000  | 1.00000  |
[0m
[RUN ] view_transformation::default_orientation
[----]   [36mGiven from ← point(0, 0, 0) 
And to ← point(0, 0, -1) 
And up ← vector(0, 1, 0) 
When t ← view_transform(from, forward, up) 
Then t = identity_matrix RESET

[PASS] view_transformation::arbitrary_transformation: (0.00s)
[PASS] view_transformation::default_orientation: (0.00s)
[RUN ] view_transformation::moves_the_world
[----]   [36mGiven from ← point(0, 0, 8)
And to ← point(0, 0, 0)
And up ← vector(0, 1, 0)
When t ← view_transform(from, forward, up)
Then t = translation(0, 0, -8)
[0m
[PASS] view_transformation::moves_the_world: (0.00s)
[RUN ] view_transformation::positive_z_direction
[----]   [36mGiven from ← point(0, 0, 0)
And to ← point(0, 0, 1)
And up ← vector(0, 1, 0)
When t ← view_transform(from, forward, up)
Then t = scaling(-1, 1, -1)
[0m
[PASS] view_transformation::positive_z_direction: (0.00s)
[====] Synthesis: Tested: 4 | Passing: 4 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 7 tests from camera:
[RUN ] camera::horizontal_pixel_size
[----]   [36mGiven c ← camera(200, 125, π/2)
Then c.pixel_size = 0.01[0m
[RUN ] camera::implementing_a_camera
[----]   [36mGiven hsize ← 160 \nAnd vsize ← 120
And field_of_view ← π/2
When c ← camera(hsize, vsize, field_of_view)
Then c.hsize = 160
And c.vsize = 120
And c.field_of_view = π/2
And c.transform = identity_matrix
[0m
[PASS] camera::horizontal_pixel_size: (0.00s)
[PASS] camera::implementing_a_camera: (0.00s)
[RUN ] camera::ray_for_pixel_center
[----]   [36mGiven c ← camera(201, 101, π/2)
When r ← ray_for_pixel(c, 50, 100)
Then r.origin = point(0, 0, 0)
And r.direction = vector(0, 0, -1)[0m
[PASS] camera::ray_for_pixel_center: (0.00s)
[RUN ] camera::ray_through_a_corner
[----]   [36mGiven c ← camera(201, 101, π/2)
When r ← ray_for_pixel(c, 50, 100)
Then r.origin = point(0, 0, 0)
And r.direction = vector(0, 0, -1)[0m
[PASS] camera::ray_through_a_corner: (0.00s)
[RUN ] camera::rendering_a_world
[----]   [36mGiven w ← default_world()
And c ← camera(11, 11, π/2)
And from ← point(0, 0, -5)
And to ← point(0, 0, 0)
And up ← vector(0, 1, 0)
And c.transform ← view_transform(from, forward, up)
When image ← render(c, w)
Then pixel_at(image, 5, 5) = color(0.38066, 0.47583, 0.2855)[0m
[RUN ] camera::ray_when_camera_transformed
[----]   [36mGiven c ← camera(201, 101, π/2)
When c.transform ← rotation_y(π/4) * translation(0, -2, 5)
And r ← ray_for_pixel(c, 50, 100)
Then r.origin = point(0, 2, -5)
And r.direction = vector(√2/2, 0, -√2/2)[0m
[PASS] camera::ray_when_camera_transformed: (0.00s)
[PASS] camera::rendering_a_world: (0.00s)
[RUN ] camera::vertical_pixel_size
[----]   [36mScenario: The pixel size for a vertical canvas
Given c ← camera(125, 200, π/2)
Then c.pixel_size = 0.01[0m
[PASS] camera::vertical_pixel_size: (0.00s)
[====] Synthesis: Tested: 7 | Passing: 7 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from putting_it_together:
[RUN ] putting_it_together::three_spheres
[PASS] putting_it_together::three_spheres: (2.71s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 5 tests from lighting:
[RUN ] lighting::behind_point
[----]   [36mGiven w ← default_world()
And p ← point(-2, 2, -2)
Then is_shadowed(w, p) is false[0m
[RUN ] lighting::behind_light
[----]   [36mGiven w ← default_world()
And p ← point(-20, 20, -20)
Then is_shadowed(w, p) is false[0m
[PASS] lighting::behind_point: (0.00s)
[PASS] lighting::behind_light: (0.00s)
[RUN ] lighting::no_shadow
[----]   [36mGiven w ← default_world()
And p ← point(0, 10, 0)
Then is_shadowed(w, p) is false[0m
[PASS] lighting::no_shadow: (0.00s)
[RUN ] lighting::shadow
[----]   [36mGiven w ← default_world()
And p ← point(10, -10, 10)
Then is_shadowed(w, p) is true[0m
[PASS] lighting::shadow: (0.00s)
[RUN ] lighting::surface_in_shadow
[----]   [36mGiven m ← material()
And position ← point(0, 0, 0)
Given eyev ← vector(0, 0, -1)
And normalv ← vector(0, 0, -1)
And light ← point_light(point(0, 0, -10), color(1, 1, 1))
And in_shadow ← true
When result ← calculate_lighting(m, light, position, eyev, normalv, in_shadow)
Then result = color(0.1, 0.1, 0.1)[0m
[PASS] lighting::surface_in_shadow: (0.00s)
[====] Synthesis: Tested: 5 | Passing: 5 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Synthesis: Tested: 0 | Passing: 0 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 2 tests from rendering_shadows:
[RUN ] rendering_shadows::hit_should_offset_the_point
[----]   [36mGiven r ← ray(point(0, 0, -5), vector(0, 0, 1))
And shape ← sphere() with:
| transform | translation(0, 0, 1) |
And i ← intersection(5, shape)
When comps ← prepare_computations(i, r)
Then comps.over_point.z < -EPSILON/2
And comps.point.z > comps.over_point.z[0m
[PASS] rendering_shadows::hit_should_offset_the_point: (0.00s)
[RUN ] rendering_shadows::shade_hit_receives_a_hit_in_shadow
[----]   [36mGiven w ← world()
And w.light ← point_light(point(0, 0, -10), color(1, 1, 1))
And s1 ← sphere()
And s1 is added to w
And s2 ← sphere() with:
| transform | translation(0, 0, 10) |
And s2 is added to w
And r ← ray(point(0, 0, 5), vector(0, 0, 1))
And i ← intersection(4, s2)
When comps ← prepare_computations(i, r)
And color ← shade_hit(w, comps)
Then color = color(0.1, 0.1, 0.1)[0m
[PASS] rendering_shadows::shade_hit_receives_a_hit_in_shadow: (0.00s)
[====] Synthesis: Tested: 2 | Passing: 2 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Synthesis: Tested: 0 | Passing: 0 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from refactoring_shapes:
[RUN ] refactoring_shapes::a_void_can_be_cast_to_a_t_shape_and_have_its_type_checked
[----]   [36mgiven that shapes are refactored, no previous tests are broken
[0m
[PASS] refactoring_shapes::a_void_can_be_cast_to_a_t_shape_and_have_its_type_checked: (0.00s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 5 tests from implementing_plane:
[RUN ] implementing_plane::coplanar_ray_intersects_plane
[----]   [36mGiven p ← plane()
And r ← ray(point(0, 0, 0), vector(0, 0, 1))
When xs ← create_intersection(p, r)
Then xs is empty
[0m
[RUN ] implementing_plane::parallel_ray_intersects_plane
[----]   [36mScenario : Intersect with a ray parallel to the plane
Given plane ← plane()
And r ← ray(point(0, 10, 0), vector(0, 0, 1))
When xs ← create_intersection(plane, r)
Then xs is empty
[0m
[PASS] implementing_plane::coplanar_ray_intersects_plane: (0.00s)
[PASS] implementing_plane::parallel_ray_intersects_plane: (0.00s)
[RUN ] implementing_plane::ray_from_above_intersects_plane
[----]   [36mGiven plane ← create_plane()
And r ← ray(point(0, 1, 0), vector(0, -1, 0))
When xs ← create_intersection(p, r)
Then xs.count = 1
And xs[0].t = 1
And xs[0].object = plane 
[0m
[PASS] implementing_plane::ray_from_above_intersects_plane: (0.00s)
[RUN ] implementing_plane::ray_from_below_intersects_plane
[----]   [36mGiven p ← plane()
And r ← ray(point(0, -1, 0), vector(0, 1, 0))
When xs ← create_intersection(p, r)
Then xs.count = 1
And xs[0].t = 1
And xs[0].object = p
[0m
[PASS] implementing_plane::ray_from_below_intersects_plane: (0.00s)
[RUN ] implementing_plane::the_normal_of_a_plane
[----]   [36mGiven plane ← create_plane()
When n1 ← plane_normal_at(plane, point(0, 0, 0))
And n2 ← plane_normal_at(plane, point(10, 0, -10))
And n3 ← plane_normal_at(plane, point(-5, 0, 150))
Then n1 = vector(0, 1, 0)
And n2 = vector(0, 1, 0)
And n3 = vector(0, 1, 0)
[0m
[PASS] implementing_plane::the_normal_of_a_plane: (0.00s)
[====] Synthesis: Tested: 5 | Passing: 5 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 2 tests from plane:
[RUN ] plane::spheres_on_a_plane_floor
[RUN ] plane::spheres_on_floor_from_above
[PASS] plane::spheres_on_a_plane_floor: (1.78s)
[PASS] plane::spheres_on_floor_from_above: (1.89s)
[====] Synthesis: Tested: 2 | Passing: 2 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 2 tests from intersect_cylinder:
[RUN ] intersect_cylinder::ray_misses_a_cylinder
[----]   [36m
Given cyl ←  cylinder()
And direction ←  normalize(<direction>)
And r ←  ray(<origin>, direction)
When xs ←  local_intersect(cyl, r)
Then xs.count = 0
[0m
[PASS] intersect_cylinder::ray_misses_a_cylinder: (0.00s)
[RUN ] intersect_cylinder::ray_strikes_cylinder
[----]   [36m
Given cyl ←  cylinder()
And direction ←  normalize(<direction>)
And r ←  ray(<origin>, direction)
When xs ←  local_intersect(cyl, r)
Then xs.count = 2
And xs[0].t = <t0>
And xs[1].t = <t1>[0m
[PASS] intersect_cylinder::ray_strikes_cylinder: (0.00s)
[====] Synthesis: Tested: 2 | Passing: 2 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 4 tests from finding_normal:
[RUN ] finding_normal::point_0_2_1
[----]   [36m
Given cyl ← cylinder()
When n ← cylinder_normal_at(cyl, point(0, -2, 1)
Then n = vector(0, 0, 1) 
[0m
[RUN ] finding_normal::point_0_5_1
[----]   [36m
Given cyl ← cylinder()
When n ← cylinder_normal_at(cyl, point(0, 5, -1)
Then n = vector(0, 0, -1) 
[0m
[PASS] finding_normal::point_0_2_1: (0.00s)
[PASS] finding_normal::point_0_5_1: (0.00s)
[RUN ] finding_normal::point_1_0_0
[----]   [36m
Given cyl ← cylinder()
When n ← cylinder_normal_at(cyl, point(1, 0, 0)
Then n = vector(1, 0, 0) 
[0m
[PASS] finding_normal::point_1_0_0: (0.00s)
[RUN ] finding_normal::point_1_1_0
[----]   [36m
Given cyl ← cylinder()
When n ← cylinder_normal_at(cyl, point(0, -2, 1)
Then n = vector(0, 0, 1) 
[0m
[PASS] finding_normal::point_1_1_0: (0.00s)
[====] Synthesis: Tested: 4 | Passing: 4 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from min_max_bounds:
[RUN ] min_max_bounds::the_default_values
[----]   [36m
Given cyl ← cylinder()
Then cyl.minimum = -infinity
And cyl.maximum = infinity[0m
[PASS] min_max_bounds::the_default_values: (0.00s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from truncating_cylinders:
[RUN ] truncating_cylinders::intersecting_constrained_cylinder
[----]   [36m
Given cyl ← cylinder()
And cyl.minimum ← 1
And cyl.maximum ← 2
And direction ← normalize(<direction>)
And r ← ray(<point>, direction)
When xs ← local_intersect(cyl, r)
Then xs.count = <count>
Examples :
 point             | direction          | count |
 point(0, 1.5, 0)  | vector(0.1, 1, 0)  | 0
 point(0, 3, -5)   | vector(0, 0, 1)    | 0
 point(0, 0, -5)   | vector(0, 0, 1)    | 0
 point(0, 2, -5)   | vector(0, 0, 1)    | 0
 point(0, 1, -5)   | vector(0, 0, 1)    | 0
 point(0, 1.5, -2) | vector(0, 0, 1)    | 2
[0m
[PASS] truncating_cylinders::intersecting_constrained_cylinder: (0.00s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 1 test from two_balls_and_a_cylinder:
[RUN ] two_balls_and_a_cylinder::two_balls_and_a_cylinder
[PASS] two_balls_and_a_cylinder::two_balls_and_a_cylinder: (1.79s)
[====] Synthesis: Tested: 1 | Passing: 1 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 6 tests from capped_cylinders:
[RUN ] capped_cylinders::intersecting_caps
[----]   [36m
Given cyl ← cylinder()
And cyl.minimum ← 1
And cyl.maximum ← 2
And cyl.closed ← true
And direction ← normalize(<direction>)
And r ← ray(<point>, direction)
When xs ← local_intersect(cyl, r)
Then xs.count = <count>

[RUN ] capped_cylinders::intersecting_caps2
[PASS] capped_cylinders::intersecting_caps: (0.00s)
[PASS] capped_cylinders::intersecting_caps2: (0.00s)
[RUN ] capped_cylinders::intersecting_caps3
[PASS] capped_cylinders::intersecting_caps3: (0.01s)
[RUN ] capped_cylinders::intersecting_caps4
[PASS] capped_cylinders::intersecting_caps4: (0.00s)
[RUN ] capped_cylinders::intersecting_caps5
[PASS] capped_cylinders::intersecting_caps5: (0.00s)
[RUN ] capped_cylinders::open_closed
[----]   [36m
Given cyl ← cylinder()
Then cyl.closed = false[0m
[PASS] capped_cylinders::open_closed: (0.00s)
[====] Synthesis: Tested: 6 | Passing: 6 | Failing: 0 | Crashing: 0 
[----] Criterion v2.4.0
[====] Running 6 tests from capped_cylinders:
[RUN ] capped_cylinders::finding_caps_normal1
[----]   [36mGiven cyl ← cylinder()
And cyl.minimum ← 1
And cyl.maximum ← 2
And cyl.closed ← true
When n ← local_normal_at(cyl, <point>)
Then n = <normal>[0m
[RUN ] capped_cylinders::finding_caps_normal2
[PASS] capped_cylinders::finding_caps_normal1: (0.00s)
[PASS] capped_cylinders::finding_caps_normal2: (0.00s)
[RUN ] capped_cylinders::finding_caps_normal3
[PASS] capped_cylinders::finding_caps_normal3: (0.00s)
[RUN ] capped_cylinders::finding_caps_normal4
[PASS] capped_cylinders::finding_caps_normal4: (0.00s)
[RUN ] capped_cylinders::finding_caps_normal5
[PASS] capped_cylinders::finding_caps_normal5: (0.00s)
[RUN ] capped_cylinders::finding_caps_normal6
[PASS] capped_cylinders::finding_caps_normal6: (0.00s)
[====] Synthesis: Tested: 6 | Passing: 6 | Failing: 0 | Crashing: 0 
